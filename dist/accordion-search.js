/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var AccordionSearch;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/mark.js/src/lib/domiterator.js":
/*!*****************************************************!*\
  !*** ./node_modules/mark.js/src/lib/domiterator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DOMIterator)\n/* harmony export */ });\n/**\n * A NodeIterator with iframes support and a method to check if an element is\n * matching a specified selector\n * @example\n * const iterator = new DOMIterator(\n *     document.querySelector(\"#context\"), true\n * );\n * iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n *     console.log(node);\n * }, node => {\n *     if(DOMIterator.matches(node.parentNode, \".ignore\")){\n *         return NodeFilter.FILTER_REJECT;\n *     } else {\n *         return NodeFilter.FILTER_ACCEPT;\n *     }\n * }, () => {\n *     console.log(\"DONE\");\n * });\n * @todo Outsource into separate repository\n */\nclass DOMIterator {\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   * @param {boolean} [iframes=true] - A boolean indicating if iframes should\n   * be handled\n   * @param {string[]} [exclude=[]] - An array containing exclusion selectors\n   * for iframes\n   * @param {number} [iframesTimeout=5000] - A number indicating the ms to\n   * wait before an iframe should be skipped, in case the load event isn't\n   * fired. This also applies if the user is offline and the resource of the\n   * iframe is online (either by the browsers \"offline\" mode or because\n   * there's no internet connection)\n   */\n  constructor(ctx, iframes = true, exclude = [], iframesTimeout = 5000) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Boolean indicating if iframe support is enabled\n     * @type {boolean}\n     * @access protected\n     */\n    this.iframes = iframes;\n    /**\n     * An array containing exclusion selectors for iframes\n     * @type {string[]}\n     */\n    this.exclude = exclude;\n    /**\n     * The maximum ms to wait for a load event before skipping an iframe\n     * @type {number}\n     */\n    this.iframesTimeout = iframesTimeout;\n  }\n\n  /**\n   * Checks if the specified DOM element matches the selector\n   * @param  {HTMLElement} element - The DOM element\n   * @param  {string|string[]} selector - The selector or an array with\n   * selectors\n   * @return {boolean}\n   * @access public\n   */\n  static matches(element, selector) {\n    const selectors = typeof selector === 'string' ? [selector] : selector,\n      fn = (\n        element.matches ||\n        element.matchesSelector ||\n        element.msMatchesSelector ||\n        element.mozMatchesSelector ||\n        element.oMatchesSelector ||\n        element.webkitMatchesSelector\n      );\n    if (fn) {\n      let match = false;\n      selectors.every(sel => {\n        if (fn.call(element, sel)) {\n          match = true;\n          return false;\n        }\n        return true;\n      });\n      return match;\n    } else { // may be false e.g. when el is a textNode\n      return false;\n    }\n  }\n\n  /**\n   * Returns all contexts filtered by duplicates (even nested)\n   * @return {HTMLElement[]} - An array containing DOM contexts\n   * @access protected\n   */\n  getContexts() {\n    let ctx,\n      filteredCtx = [];\n    if (typeof this.ctx === 'undefined' || !this.ctx) { // e.g. null\n      ctx = [];\n    } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\n      ctx = Array.prototype.slice.call(this.ctx);\n    } else if (Array.isArray(this.ctx)) {\n      ctx = this.ctx;\n    } else if (typeof this.ctx === 'string') {\n      ctx = Array.prototype.slice.call(\n        document.querySelectorAll(this.ctx)\n      );\n    } else { // e.g. HTMLElement or element inside iframe\n      ctx = [this.ctx];\n    }\n    // filter duplicate text nodes\n    ctx.forEach(ctx => {\n      const isDescendant = filteredCtx.filter(contexts => {\n        return contexts.contains(ctx);\n      }).length > 0;\n      if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\n        filteredCtx.push(ctx);\n      }\n    });\n    return filteredCtx;\n  }\n\n  /**\n   * @callback DOMIterator~getIframeContentsSuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Calls the success callback function with the iframe document. If it can't\n   * be accessed it calls the error callback function\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} [errorFn]\n   * @access protected\n   */\n  getIframeContents(ifr, successFn, errorFn = () => {}) {\n    let doc;\n    try {\n      const ifrWin = ifr.contentWindow;\n      doc = ifrWin.document;\n      if (!ifrWin || !doc) { // no permission = null. Undefined in Phantom\n        throw new Error('iframe inaccessible');\n      }\n    } catch (e) {\n      errorFn();\n    }\n    if (doc) {\n      successFn(doc);\n    }\n  }\n\n  /**\n   * Checks if an iframe is empty (if about:blank is the shown page)\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @return {boolean}\n   * @access protected\n   */\n  isIframeBlank(ifr) {\n    const bl = 'about:blank',\n      src = ifr.getAttribute('src').trim(),\n      href = ifr.contentWindow.location.href;\n    return href === bl && src !== bl && src;\n  }\n\n  /**\n   * Observes the onload event of an iframe and calls the success callback or\n   * the error callback if the iframe is inaccessible. If the event isn't\n   * fired within the specified {@link DOMIterator#iframesTimeout}, then it'll\n   * call the error callback too\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} errorFn\n   * @access protected\n   */\n  observeIframeLoad(ifr, successFn, errorFn) {\n    let called = false,\n      tout = null;\n    const listener = () => {\n      if (called) {\n        return;\n      }\n      called = true;\n      clearTimeout(tout);\n      try {\n        if (!this.isIframeBlank(ifr)) {\n          ifr.removeEventListener('load', listener);\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } catch (e) { // isIframeBlank maybe throws throws an error\n        errorFn();\n      }\n    };\n    ifr.addEventListener('load', listener);\n    tout = setTimeout(listener, this.iframesTimeout);\n  }\n\n  /**\n   * Callback when the iframe is ready\n   * @callback DOMIterator~onIframeReadySuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Callback if the iframe can't be accessed\n   * @callback DOMIterator~onIframeReadyErrorCallback\n   */\n  /**\n   * Calls the callback if the specified iframe is ready for DOM access\n   * @param  {HTMLElement} ifr - The iframe DOM element\n   * @param  {DOMIterator~onIframeReadySuccessCallback} successFn - Success\n   * callback\n   * @param {DOMIterator~onIframeReadyErrorCallback} errorFn - Error callback\n   * @see {@link http://stackoverflow.com/a/36155560/3894981} for\n   * background information\n   * @access protected\n   */\n  onIframeReady(ifr, successFn, errorFn) {\n    try {\n      if (ifr.contentWindow.document.readyState === 'complete') {\n        if (this.isIframeBlank(ifr)) {\n          this.observeIframeLoad(ifr, successFn, errorFn);\n        } else {\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } else {\n        this.observeIframeLoad(ifr, successFn, errorFn);\n      }\n    } catch (e) { // accessing document failed\n      errorFn();\n    }\n  }\n\n  /**\n   * Callback when all iframes are ready for DOM access\n   * @callback DOMIterator~waitForIframesDoneCallback\n   */\n  /**\n   * Iterates over all iframes and calls the done callback when all of them\n   * are ready for DOM access (including nested ones)\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~waitForIframesDoneCallback} done - Done callback\n   */\n  waitForIframes(ctx, done) {\n    let eachCalled = 0;\n    this.forEachIframe(ctx, () => true, ifr => {\n      eachCalled++;\n      this.waitForIframes(ifr.querySelector('html'), () => {\n        if (!(--eachCalled)) {\n          done();\n        }\n      });\n    }, handled => {\n      if (!handled) {\n        done();\n      }\n    });\n  }\n\n  /**\n   * Callback allowing to filter an iframe. Must return true when the element\n   * should remain, otherwise false\n   * @callback DOMIterator~forEachIframeFilterCallback\n   * @param {HTMLElement} iframe - The iframe DOM element\n   */\n  /**\n   * Callback for each iframe content\n   * @callback DOMIterator~forEachIframeEachCallback\n   * @param {HTMLElement} content - The iframe document\n   */\n  /**\n   * Callback if all iframes inside the context were handled\n   * @callback DOMIterator~forEachIframeEndCallback\n   * @param {number} handled - The number of handled iframes (those who\n   * wheren't filtered)\n   */\n  /**\n   * Iterates over all iframes inside the specified context and calls the\n   * callbacks when they're ready. Filters iframes based on the instance\n   * exclusion selectors\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~forEachIframeFilterCallback} filter - Filter callback\n   * @param {DOMIterator~forEachIframeEachCallback} each - Each callback\n   * @param {DOMIterator~forEachIframeEndCallback} [end] - End callback\n   * @access protected\n   */\n  forEachIframe(ctx, filter, each, end = () => {}) {\n    let ifr = ctx.querySelectorAll('iframe'),\n      open = ifr.length,\n      handled = 0;\n    ifr = Array.prototype.slice.call(ifr);\n    const checkEnd = () => {\n      if (--open <= 0) {\n        end(handled);\n      }\n    };\n    if (!open) {\n      checkEnd();\n    }\n    ifr.forEach(ifr => {\n      if (DOMIterator.matches(ifr, this.exclude)) {\n        checkEnd();\n      } else {\n        this.onIframeReady(ifr, con => {\n          if (filter(ifr)) {\n            handled++;\n            each(con);\n          }\n          checkEnd();\n        }, checkEnd);\n      }\n    });\n  }\n\n  /**\n   * Creates a NodeIterator on the specified context\n   * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {DOMIterator~filterCb} filter\n   * @return {NodeIterator}\n   * @access protected\n   */\n  createIterator(ctx, whatToShow, filter) {\n    return document.createNodeIterator(ctx, whatToShow, filter, false);\n  }\n\n  /**\n   * Creates an instance of DOMIterator in an iframe\n   * @param {HTMLDocument} contents - Iframe document\n   * @return {DOMIterator}\n   * @access protected\n   */\n  createInstanceOnIframe(contents) {\n    return new DOMIterator(contents.querySelector('html'), this.iframes);\n  }\n\n  /**\n   * Checks if an iframe occurs between two nodes, more specifically if an\n   * iframe occurs before the specified node and after the specified prevNode\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} ifr - The iframe to check against\n   * @return {boolean}\n   * @access protected\n   */\n  compareNodeIframe(node, prevNode, ifr) {\n    const compCurr = node.compareDocumentPosition(ifr),\n      prev = Node.DOCUMENT_POSITION_PRECEDING;\n    if (compCurr & prev) {\n      if (prevNode !== null) {\n        const compPrev = prevNode.compareDocumentPosition(ifr),\n          after = Node.DOCUMENT_POSITION_FOLLOWING;\n        if (compPrev & after) {\n          return true;\n        }\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @typedef {DOMIterator~getIteratorNodeReturn}\n   * @type {object.<string>}\n   * @property {HTMLElement} prevNode - The previous node or null if there is\n   * no\n   * @property {HTMLElement} node - The current node\n   */\n  /**\n   * Returns the previous and current node of the specified iterator\n   * @param {NodeIterator} itr - The iterator\n   * @return {DOMIterator~getIteratorNodeReturn}\n   * @access protected\n   */\n  getIteratorNode(itr) {\n    const prevNode = itr.previousNode();\n    let node;\n    if (prevNode === null) {\n      node = itr.nextNode();\n    } else {\n      node = itr.nextNode() && itr.nextNode();\n    }\n    return {\n      prevNode,\n      node\n    };\n  }\n\n  /**\n   * An array containing objects. The object key \"val\" contains an iframe\n   * DOM element. The object key \"handled\" contains a boolean indicating if\n   * the iframe was handled already.\n   * It wouldn't be enough to save all open or all already handled iframes.\n   * The information of open iframes is necessary because they may occur after\n   * all other text nodes (and compareNodeIframe would never be true). The\n   * information of already handled iframes is necessary as otherwise they may\n   * be handled multiple times\n   * @typedef DOMIterator~checkIframeFilterIfr\n   * @type {object[]}\n   */\n  /**\n   * Checks if an iframe wasn't handled already and if so, calls\n   * {@link DOMIterator#compareNodeIframe} to check if it should be handled.\n   * Information wheter an iframe was or wasn't handled is given within the\n   * <code>ifr</code> dictionary\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} currIfr - The iframe to check\n   * @param {DOMIterator~checkIframeFilterIfr} ifr - The iframe dictionary.\n   * Will be manipulated (by reference)\n   * @return {boolean} Returns true when it should be handled, otherwise false\n   * @access protected\n   */\n  checkIframeFilter(node, prevNode, currIfr, ifr) {\n    let key = false, // false === doesn't exist\n      handled = false;\n    ifr.forEach((ifrDict, i) => {\n      if (ifrDict.val === currIfr) {\n        key = i;\n        handled = ifrDict.handled;\n      }\n    });\n    if (this.compareNodeIframe(node, prevNode, currIfr)) {\n      if (key === false && !handled) {\n        ifr.push({\n          val: currIfr,\n          handled: true\n        });\n      } else if (key !== false && !handled) {\n        ifr[key].handled = true;\n      }\n      return true;\n    }\n    if (key === false) {\n      ifr.push({\n        val: currIfr,\n        handled: false\n      });\n    }\n    return false;\n  }\n\n  /**\n   * Creates an iterator on all open iframes in the specified array and calls\n   * the end callback when finished\n   * @param {DOMIterator~checkIframeFilterIfr} ifr\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} eCb - Each callback\n   * @param {DOMIterator~filterCb} fCb\n   * @access protected\n   */\n  handleOpenIframes(ifr, whatToShow, eCb, fCb) {\n    ifr.forEach(ifrDict => {\n      if (!ifrDict.handled) {\n        this.getIframeContents(ifrDict.val, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, eCb, fCb\n          );\n        });\n      }\n    });\n  }\n\n  /**\n   * Iterates through all nodes in the specified context and handles iframe\n   * nodes at the correct position\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {HTMLElement} ctx - The context\n   * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback\n   * @param {DOMIterator~filterCb} filterCb - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback\n   * @access protected\n   */\n  iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\n    const itr = this.createIterator(ctx, whatToShow, filterCb);\n    let ifr = [],\n      elements = [],\n      node, prevNode, retrieveNodes = () => {\n        ({\n          prevNode,\n          node\n        } = this.getIteratorNode(itr));\n        return node;\n      };\n    while (retrieveNodes()) {\n      if (this.iframes) {\n        this.forEachIframe(ctx, currIfr => {\n          // note that ifr will be manipulated here\n          return this.checkIframeFilter(node, prevNode, currIfr, ifr);\n        }, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, ifrNode => elements.push(ifrNode), filterCb\n          );\n        });\n      }\n      // it's faster to call the each callback in an array loop\n      // than in this while loop\n      elements.push(node);\n    }\n    elements.forEach(node => {\n      eachCb(node);\n    });\n    if (this.iframes) {\n      this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\n    }\n    doneCb();\n  }\n\n  /**\n   * Callback for each node\n   * @callback DOMIterator~forEachNodeCallback\n   * @param {HTMLElement} node - The DOM text node element\n   */\n  /**\n   * Callback if all contexts were handled\n   * @callback DOMIterator~forEachNodeEndCallback\n   */\n  /**\n   * Iterates over all contexts and initializes\n   * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} each - Each callback\n   * @param {DOMIterator~filterCb} filter - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} done - End callback\n   * @access public\n   */\n  forEachNode(whatToShow, each, filter, done = () => {}) {\n    const contexts = this.getContexts();\n    let open = contexts.length;\n    if (!open) {\n      done();\n    }\n    contexts.forEach(ctx => {\n      const ready = () => {\n        this.iterateThroughNodes(whatToShow, ctx, each, filter, () => {\n          if (--open <= 0) { // call end all contexts were handled\n            done();\n          }\n        });\n      };\n      // wait for iframes to avoid recursive calls, otherwise this would\n      // perhaps reach the recursive function call limit with many nodes\n      if (this.iframes) {\n        this.waitForIframes(ctx, ready);\n      } else {\n        ready();\n      }\n    });\n  }\n\n  /**\n   * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or\n   * NodeFilter.FILTER_REJECT\n   * @see {@link http://tinyurl.com/zdczmm2}\n   * @callback DOMIterator~filterCb\n   * @param {HTMLElement} node - The node to filter\n   */\n  /**\n   * @typedef DOMIterator~whatToShow\n   * @see {@link http://tinyurl.com/zfqqkx2}\n   * @type {number}\n   */\n}\n\n\n//# sourceURL=webpack://AccordionSearch/./node_modules/mark.js/src/lib/domiterator.js?");

/***/ }),

/***/ "./node_modules/mark.js/src/lib/mark.js":
/*!**********************************************!*\
  !*** ./node_modules/mark.js/src/lib/mark.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mark)\n/* harmony export */ });\n/* harmony import */ var _domiterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domiterator */ \"./node_modules/mark.js/src/lib/domiterator.js\");\n\n\n/**\n * Marks search terms in DOM elements\n * @example\n * new Mark(document.querySelector(\".context\")).mark(\"lorem ipsum\");\n * @example\n * new Mark(document.querySelector(\".context\")).markRegExp(/lorem/gmi);\n */\nclass Mark { // eslint-disable-line no-unused-vars\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   */\n  constructor(ctx) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Specifies if the current browser is a IE (necessary for the node\n     * normalization bug workaround). See {@link Mark#unwrapMatches}\n     * @type {boolean}\n     * @access protected\n     */\n    this.ie = false;\n    const ua = window.navigator.userAgent;\n    if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\n      this.ie = true;\n    }\n  }\n\n  /**\n   * Options defined by the user. They will be initialized from one of the\n   * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},\n   * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.\n   * @type {object}\n   * @param {object} [val] - An object that will be merged with defaults\n   * @access protected\n   */\n  set opt(val) {\n    this._opt = Object.assign({}, {\n      'element': '',\n      'className': '',\n      'exclude': [],\n      'iframes': false,\n      'iframesTimeout': 5000,\n      'separateWordSearch': true,\n      'diacritics': true,\n      'synonyms': {},\n      'accuracy': 'partially',\n      'acrossElements': false,\n      'caseSensitive': false,\n      'ignoreJoiners': false,\n      'ignoreGroups': 0,\n      'ignorePunctuation': [],\n      'wildcards': 'disabled',\n      'each': () => {},\n      'noMatch': () => {},\n      'filter': () => true,\n      'done': () => {},\n      'debug': false,\n      'log': window.console\n    }, val);\n  }\n\n  get opt() {\n    return this._opt;\n  }\n\n  /**\n   * An instance of DOMIterator\n   * @type {DOMIterator}\n   * @access protected\n   */\n  get iterator() {\n    // always return new instance in case there were option changes\n    return new _domiterator__WEBPACK_IMPORTED_MODULE_0__.default(\n      this.ctx,\n      this.opt.iframes,\n      this.opt.exclude,\n      this.opt.iframesTimeout\n    );\n  }\n\n  /**\n   * Logs a message if log is enabled\n   * @param {string} msg - The message to log\n   * @param {string} [level=\"debug\"] - The log level, e.g. <code>warn</code>\n   * <code>error</code>, <code>debug</code>\n   * @access protected\n   */\n  log(msg, level = 'debug') {\n    const log = this.opt.log;\n    if (!this.opt.debug) {\n      return;\n    }\n    if (typeof log === 'object' && typeof log[level] === 'function') {\n      log[level](`mark.js: ${msg}`);\n    }\n  }\n\n  /**\n   * Escapes a string for usage within a regular expression\n   * @param {string} str - The string to escape\n   * @return {string}\n   * @access protected\n   */\n  escapeStr(str) {\n    // eslint-disable-next-line no-useless-escape\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified search\n   * term including synonyms, diacritics and accuracy if defined\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createRegExp(str) {\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.setupWildcardsRegExp(str);\n    }\n    str = this.escapeStr(str);\n    if (Object.keys(this.opt.synonyms).length) {\n      str = this.createSynonymsRegExp(str);\n    }\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    if (this.opt.diacritics) {\n      str = this.createDiacriticsRegExp(str);\n    }\n    str = this.createMergedBlanksRegExp(str);\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.createJoinersRegExp(str);\n    }\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.createWildcardsRegExp(str);\n    }\n    str = this.createAccuracyRegExp(str);\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string to match the defined synonyms\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createSynonymsRegExp(str) {\n    const syn = this.opt.synonyms,\n      sens = this.opt.caseSensitive ? '' : 'i',\n      // add replacement character placeholder before and after the\n      // synonym group\n      joinerPlaceholder = this.opt.ignoreJoiners ||\n                this.opt.ignorePunctuation.length ? '\\u0000' : '';\n    for (let index in syn) {\n      if (syn.hasOwnProperty(index)) {\n        const value = syn[index],\n          k1 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(index) :\n            this.escapeStr(index),\n          k2 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(value) :\n            this.escapeStr(value);\n        if (k1 !== '' && k2 !== '') {\n          str = str.replace(\n            new RegExp(\n              `(${this.escapeStr(k1)}|${this.escapeStr(k2)})`,\n              `gm${sens}`\n            ),\n            joinerPlaceholder +\n            `(${this.processSynomyms(k1)}|` +\n            `${this.processSynomyms(k2)})` +\n            joinerPlaceholder\n          );\n        }\n      }\n    }\n    return str;\n  }\n\n  /**\n   * Setup synonyms to work with ignoreJoiners and or ignorePunctuation\n   * @param {string} str - synonym key or value to process\n   * @return {string} - processed synonym string\n   */\n  processSynomyms(str) {\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    return str;\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupWildcardsRegExp(str) {\n    // replace single character wildcard with unicode 0001\n    str = str.replace(/(?:\\\\)*\\?/g, val => {\n      return val.charAt(0) === '\\\\' ? '?' : '\\u0001';\n    });\n    // replace multiple character wildcard with unicode 0002\n    return str.replace(/(?:\\\\)*\\*/g, val => {\n      return val.charAt(0) === '\\\\' ? '*' : '\\u0002';\n    });\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createWildcardsRegExp(str) {\n    // default to \"enable\" (i.e. to not include spaces)\n    // \"withSpaces\" uses `[\\\\S\\\\s]` instead of `.` because the latter\n    // does not match new line characters\n    let spaces = this.opt.wildcards === 'withSpaces';\n    return str\n    // replace unicode 0001 with a RegExp class to match any single\n    // character, or any single non-whitespace character depending\n    // on the setting\n      .replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?')\n    // replace unicode 0002 with a RegExp class to match zero or\n    // more characters, or zero or more non-whitespace characters\n    // depending on the setting\n      .replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * designated characters (soft hyphens & zero width characters)\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupIgnoreJoinersRegExp(str) {\n    // adding a \"null\" unicode character as it will not be modified by the\n    // other \"create\" regular expression functions\n    return str.replace(/[^(|)\\\\]/g, (val, indx, original) => {\n      // don't add a null after an opening \"(\", around a \"|\" or before\n      // a closing \"(\", or between an escapement (e.g. \\+)\n      let nextChar = original.charAt(indx + 1);\n      if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\n        return val;\n      } else {\n        return val + '\\u0000';\n      }\n    });\n  }\n\n  /**\n   * Creates a regular expression string to allow ignoring of designated\n   * characters (soft hyphens, zero width characters & punctuation) based on\n   * the specified option values of <code>ignorePunctuation</code> and\n   * <code>ignoreJoiners</code>\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createJoinersRegExp(str) {\n    let joiner = [];\n    const ignorePunctuation = this.opt.ignorePunctuation;\n    if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\n      joiner.push(this.escapeStr(ignorePunctuation.join('')));\n    }\n    if (this.opt.ignoreJoiners) {\n      // u+00ad = soft hyphen\n      // u+200b = zero-width space\n      // u+200c = zero-width non-joiner\n      // u+200d = zero-width joiner\n      joiner.push('\\\\u00ad\\\\u200b\\\\u200c\\\\u200d');\n    }\n    return joiner.length ?\n      str.split(/\\u0000+/).join(`[${joiner.join('')}]*`) :\n      str;\n  }\n\n  /**\n   * Creates a regular expression string to match diacritics\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createDiacriticsRegExp(str) {\n    const sens = this.opt.caseSensitive ? '' : 'i',\n      dct = this.opt.caseSensitive ? [\n        'aàáảãạăằắẳẵặâầấẩẫậäåāą', 'AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ',\n        'cçćč', 'CÇĆČ', 'dđď', 'DĐĎ',\n        'eèéẻẽẹêềếểễệëěēę', 'EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\n        'iìíỉĩịîïī', 'IÌÍỈĨỊÎÏĪ', 'lł', 'LŁ', 'nñňń',\n        'NÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøō', 'OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ',\n        'rř', 'RŘ', 'sšśșş', 'SŠŚȘŞ',\n        'tťțţ', 'TŤȚŢ', 'uùúủũụưừứửữựûüůū', 'UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ',\n        'yýỳỷỹỵÿ', 'YÝỲỶỸỴŸ', 'zžżź', 'ZŽŻŹ'\n      ] : [\n        'aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćčCÇĆČ',\n        'dđďDĐĎ', 'eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\n        'iìíỉĩịîïīIÌÍỈĨỊÎÏĪ', 'lłLŁ', 'nñňńNÑŇŃ',\n        'oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rřRŘ',\n        'sšśșşSŠŚȘŞ', 'tťțţTŤȚŢ',\n        'uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿYÝỲỶỸỴŸ', 'zžżźZŽŻŹ'\n      ];\n    let handled = [];\n    str.split('').forEach(ch => {\n      dct.every(dct => {\n        // Check if the character is inside a diacritics list\n        if (dct.indexOf(ch) !== -1) {\n          // Check if the related diacritics list was not\n          // handled yet\n          if (handled.indexOf(dct) > -1) {\n            return false;\n          }\n          // Make sure that the character OR any other\n          // character in the diacritics list will be matched\n          str = str.replace(\n            new RegExp(`[${dct}]`, `gm${sens}`), `[${dct}]`\n          );\n          handled.push(dct);\n        }\n        return true;\n      });\n    });\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string that merges whitespace characters\n   * including subsequent ones into a single pattern, one or multiple\n   * whitespaces\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createMergedBlanksRegExp(str) {\n    return str.replace(/[\\s]+/gmi, '[\\\\s]+');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified string with\n   * the defined accuracy. As in the regular expression of \"exactly\" can be\n   * a group containing a blank at the beginning, all regular expressions will\n   * be created with two groups. The first group can be ignored (may contain\n   * the said blank), the second contains the actual match\n   * @param  {string} str - The searm term to be used\n   * @return {str}\n   * @access protected\n   */\n  createAccuracyRegExp(str) {\n    const chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿';\n    let acc = this.opt.accuracy,\n      val = typeof acc === 'string' ? acc : acc.value,\n      ls = typeof acc === 'string' ? [] : acc.limiters,\n      lsJoin = '';\n    ls.forEach(limiter => {\n      lsJoin += `|${this.escapeStr(limiter)}`;\n    });\n    switch (val) {\n    case 'partially':\n    default:\n      return `()(${str})`;\n    case 'complementary':\n      lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\n      return `()([^${lsJoin}]*${str}[^${lsJoin}]*)`;\n    case 'exactly':\n      return `(^|\\\\s${lsJoin})(${str})(?=$|\\\\s${lsJoin})`;\n    }\n  }\n\n  /**\n   * @typedef Mark~separatedKeywords\n   * @type {object.<string>}\n   * @property {array.<string>} keywords - The list of keywords\n   * @property {number} length - The length\n   */\n  /**\n   * Returns a list of keywords dependent on whether separate word search\n   * was defined. Also it filters empty keywords\n   * @param {array} sv - The array of keywords\n   * @return {Mark~separatedKeywords}\n   * @access protected\n   */\n  getSeparatedKeywords(sv) {\n    let stack = [];\n    sv.forEach(kw => {\n      if (!this.opt.separateWordSearch) {\n        if (kw.trim() && stack.indexOf(kw) === -1) {\n          stack.push(kw);\n        }\n      } else {\n        kw.split(' ').forEach(kwSplitted => {\n          if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\n            stack.push(kwSplitted);\n          }\n        });\n      }\n    });\n    return {\n      // sort because of https://git.io/v6USg\n      'keywords': stack.sort((a, b) => {\n        return b.length - a.length;\n      }),\n      'length': stack.length\n    };\n  }\n\n  /**\n   * Check if a value is a number\n   * @param {number|string} value - the value to check;\n   * numeric strings allowed\n   * @return {boolean}\n   * @access protected\n   */\n  isNumeric(value) {\n    // http://stackoverflow.com/a/16655847/145346\n    // eslint-disable-next-line eqeqeq\n    return Number(parseFloat(value)) == value;\n  }\n\n  /**\n   * @typedef Mark~rangeObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} length - The length of the string to mark within the\n   * composite value.\n   */\n  /**\n   * @typedef Mark~setOfRanges\n   * @type {object[]}\n   * @property {Mark~rangeObject}\n   */\n  /**\n   * Returns a processed list of integer offset indexes that do not overlap\n   * each other, and remove any string values or additional elements\n   * @param {Mark~setOfRanges} array - unprocessed raw array\n   * @return {Mark~setOfRanges} - processed array with any invalid entries\n   * removed\n   * @throws Will throw an error if an array of objects is not passed\n   * @access protected\n   */\n  checkRanges(array) {\n    // start and length indexes are included in an array of objects\n    // [{start: 0, length: 1}, {start: 4, length: 5}]\n    // quick validity check of the first entry only\n    if (\n      !Array.isArray(array) ||\n      Object.prototype.toString.call( array[0] ) !== '[object Object]'\n    ) {\n      this.log('markRanges() will only accept an array of objects');\n      this.opt.noMatch(array);\n      return [];\n    }\n    const stack = [];\n    let last = 0;\n    array\n    // acending sort to ensure there is no overlap in start & end\n    // offsets\n      .sort((a, b) => {\n        return a.start - b.start;\n      })\n      .forEach(item => {\n        let {start, end, valid} = this.callNoMatchOnInvalidRanges(item, last);\n        if (valid) {\n          // preserve item in case there are extra key:values within\n          item.start = start;\n          item.length = end - start;\n          stack.push(item);\n          last = end;\n        }\n      });\n    return stack;\n  }\n\n  /**\n   * @typedef Mark~validObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} end - The calculated end position within the composite\n   * value.\n   * @property {boolean} valid - boolean value indicating that the start and\n   * calculated end range is valid\n   */\n  /**\n    * Initial validation of ranges for markRanges. Preliminary checks are done\n    * to ensure the start and length values exist and are not zero or non-\n    * numeric\n    * @param {Mark~rangeObject} range - the current range object\n    * @param {number} last - last index of range\n    * @return {Mark~validObject}\n    * @access protected\n    */\n  callNoMatchOnInvalidRanges(range, last) {\n    let start, end,\n      valid = false;\n    if (range && typeof range.start !== 'undefined') {\n      start = parseInt(range.start, 10);\n      end = start + parseInt(range.length, 10);\n      // ignore overlapping values & non-numeric entries\n      if (\n        this.isNumeric(range.start) &&\n        this.isNumeric(range.length) &&\n        end - last > 0 &&\n        end - start > 0\n      ) {\n        valid = true;\n      } else {\n        this.log(\n          'Ignoring invalid or overlapping range: ' +\n                    `${JSON.stringify(range)}`\n        );\n        this.opt.noMatch(range);\n      }\n    } else {\n      this.log(`Ignoring invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * Check valid range for markRanges. Check ranges with access to the context\n   * string. Range values are double checked, lengths that extend the mark\n   * beyond the string length are limitied and ranges containing only\n   * whitespace are ignored\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {number} originalLength - original length of the context string\n   * @param {string} string - current content string\n   * @return {Mark~validObject}\n   * @access protected\n   */\n  checkWhitespaceRanges(range, originalLength, string) {\n    let end,\n      valid = true,\n      // the max value changes after the DOM is manipulated\n      max = string.length,\n      // adjust offset to account for wrapped text node\n      offset = originalLength - max,\n      start = parseInt(range.start, 10) - offset;\n    // make sure to stop at max\n    start = start > max ? max : start;\n    end = start + parseInt(range.length, 10);\n    if (end > max) {\n      end = max;\n      this.log(`End range automatically set to the max value of ${max}`);\n    }\n    if (start < 0 || end - start < 0 || start > max || end > max) {\n      valid = false;\n      this.log(`Invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\n      valid = false;\n      // whitespace only; even if wrapped it is not visible\n      this.log('Skipping whitespace only range: ' +JSON.stringify(range));\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * @typedef Mark~getTextNodesDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Callback\n   * @callback Mark~getTextNodesCallback\n   * @param {Mark~getTextNodesDict}\n   */\n  /**\n   * Calls the callback with an object containing all text nodes (including\n   * iframe text nodes) with start and end positions and the composite value\n   * of them (string)\n   * @param {Mark~getTextNodesCallback} cb - Callback\n   * @access protected\n   */\n  getTextNodes(cb) {\n    let val = '',\n      nodes = [];\n    this.iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n      nodes.push({\n        start: val.length,\n        end: (val += node.textContent).length,\n        node\n      });\n    }, node => {\n      if (this.matchesExclude(node.parentNode)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, () => {\n      cb({\n        value: val,\n        nodes: nodes\n      });\n    });\n  }\n\n  /**\n   * Checks if an element matches any of the specified exclude selectors. Also\n   * it checks for elements in which no marks should be performed (e.g.\n   * script and style tags) and optionally already marked elements\n   * @param  {HTMLElement} el - The element to check\n   * @return {boolean}\n   * @access protected\n   */\n  matchesExclude(el) {\n    return _domiterator__WEBPACK_IMPORTED_MODULE_0__.default.matches(el, this.opt.exclude.concat([\n      // ignores the elements itself, not their childrens (selector *)\n      'script', 'style', 'title', 'head', 'html'\n    ]));\n  }\n\n  /**\n   * Wraps the instance element and class around matches that fit the start\n   * and end positions within the node\n   * @param  {HTMLElement} node - The DOM text node\n   * @param  {number} start - The position where to start wrapping\n   * @param  {number} end - The position where to end wrapping\n   * @return {HTMLElement} Returns the splitted text node that will appear\n   * after the wrapped text node\n   * @access protected\n   */\n  wrapRangeInTextNode(node, start, end) {\n    const hEl = !this.opt.element ? 'mark' : this.opt.element,\n      startNode = node.splitText(start),\n      ret = startNode.splitText(end - start);\n    let repl = document.createElement(hEl);\n    repl.setAttribute('data-markjs', 'true');\n    if (this.opt.className) {\n      repl.setAttribute('class', this.opt.className);\n    }\n    repl.textContent = startNode.textContent;\n    startNode.parentNode.replaceChild(repl, startNode);\n    return ret;\n  }\n\n  /**\n   * @typedef Mark~wrapRangeInMappedTextNodeDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Each callback\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} node - The wrapped DOM element\n   * @param {number} lastIndex - The last matching position within the\n   * composite value of text nodes\n   */\n  /**\n   * Filter callback\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {HTMLElement} node - The matching text node DOM element\n   */\n  /**\n   * Determines matches by start and end positions using the text node\n   * dictionary even across text nodes and calls\n   * {@link Mark#wrapRangeInTextNode} to wrap them\n   * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary\n   * @param  {number} start - The start position of the match\n   * @param  {number} end - The end position of the match\n   * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback\n   * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback\n   * @access protected\n   */\n  wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\n    // iterate over all text nodes to find the one matching the positions\n    dict.nodes.every((n, i) => {\n      const sibl = dict.nodes[i + 1];\n      if (typeof sibl === 'undefined' || sibl.start > start) {\n        if (!filterCb(n.node)) {\n          return false;\n        }\n        // map range from dict.value to text node\n        const s = start - n.start,\n          e = (end > n.end ? n.end : end) - n.start,\n          startStr = dict.value.substr(0, n.start),\n          endStr = dict.value.substr(e + n.start);\n        n.node = this.wrapRangeInTextNode(n.node, s, e);\n        // recalculate positions to also find subsequent matches in the\n        // same text node. Necessary as the text node in dict now only\n        // contains the splitted part after the wrapped one\n        dict.value = startStr + endStr;\n        dict.nodes.forEach((k, j) => {\n          if (j >= i) {\n            if (dict.nodes[j].start > 0 && j !== i) {\n              dict.nodes[j].start -= e;\n            }\n            dict.nodes[j].end -= e;\n          }\n        });\n        end -= e;\n        eachCb(n.node.previousSibling, n.start);\n        if (end > n.end) {\n          start = n.end;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches within single HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesFilterCallback} filterCb\n   * @param {Mark~wrapMatchesEachCallback} eachCb\n   * @param {Mark~wrapMatchesEndCallback} endCb\n   * @access protected\n   */\n  wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      dict.nodes.forEach(node => {\n        node = node.node;\n        let match;\n        while (\n          (match = regex.exec(node.textContent)) !== null &&\n          match[matchIdx] !== ''\n        ) {\n          if (!filterCb(match[matchIdx], node)) {\n            continue;\n          }\n          let pos = match.index;\n          if (matchIdx !== 0) {\n            for (let i = 1; i < matchIdx; i++) {\n              pos += match[i].length;\n            }\n          }\n          node = this.wrapRangeInTextNode(\n            node,\n            pos,\n            pos + match[matchIdx].length\n          );\n          eachCb(node.previousSibling);\n          // reset index of last match as the node changed and the\n          // index isn't valid anymore http://tinyurl.com/htsudjd\n          regex.lastIndex = 0;\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesAcrossElementsEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesAcrossElementsFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesAcrossElementsEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches across all HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb\n   * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb\n   * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb\n   * @access protected\n   */\n  wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      let match;\n      while (\n        (match = regex.exec(dict.value)) !== null &&\n        match[matchIdx] !== ''\n      ) {\n        // calculate range inside dict.value\n        let start = match.index;\n        if (matchIdx !== 0) {\n          for (let i = 1; i < matchIdx; i++) {\n            start += match[i].length;\n          }\n        }\n        const end = start + match[matchIdx].length;\n        // note that dict will be updated automatically, as it'll change\n        // in the wrapping process, due to the fact that text\n        // nodes will be splitted\n        this.wrapRangeInMappedTextNode(dict, start, end, node => {\n          return filterCb(match[matchIdx], node);\n        }, (node, lastIndex) => {\n          regex.lastIndex = lastIndex;\n          eachCb(node);\n        });\n      }\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapRangeFromIndexEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {Mark~rangeObject} range - the current range object; provided\n   * start and length values will be numeric integers modified from the\n   * provided original ranges.\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapRangeFromIndexFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapRangeFromIndexEndCallback\n   */\n  /**\n   * Wraps the indicated ranges across all HTML elements in all contexts\n   * @param {Mark~setOfRanges} ranges\n   * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb\n   * @param {Mark~wrapRangeFromIndexEachCallback} eachCb\n   * @param {Mark~wrapRangeFromIndexEndCallback} endCb\n   * @access protected\n   */\n  wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\n    this.getTextNodes(dict => {\n      const originalLength = dict.value.length;\n      ranges.forEach((range, counter) => {\n        let {start, end, valid} = this.checkWhitespaceRanges(\n          range,\n          originalLength,\n          dict.value\n        );\n        if (valid) {\n          this.wrapRangeInMappedTextNode(dict, start, end, node => {\n            return filterCb(\n              node,\n              range,\n              dict.value.substring(start, end),\n              counter\n            );\n          }, node => {\n            eachCb(node, range);\n          });\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Unwraps the specified DOM node with its content (text nodes or HTML)\n   * without destroying possibly present events (using innerHTML) and\n   * normalizes the parent at the end (merge splitted text nodes)\n   * @param  {HTMLElement} node - The DOM node to unwrap\n   * @access protected\n   */\n  unwrapMatches(node) {\n    const parent = node.parentNode;\n    let docFrag = document.createDocumentFragment();\n    while (node.firstChild) {\n      docFrag.appendChild(node.removeChild(node.firstChild));\n    }\n    parent.replaceChild(docFrag, node);\n    if (!this.ie) { // use browser's normalize method\n      parent.normalize();\n    } else { // custom method (needs more time)\n      this.normalizeTextNode(parent);\n    }\n  }\n\n  /**\n   * Normalizes text nodes. It's a workaround for the native normalize method\n   * that has a bug in IE (see attached link). Should only be used in IE\n   * browsers as it's slower than the native method.\n   * @see {@link http://tinyurl.com/z5asa8c}\n   * @param {HTMLElement} node - The DOM node to normalize\n   * @access protected\n   */\n  normalizeTextNode(node) {\n    if (!node) {\n      return;\n    }\n    if (node.nodeType === 3) {\n      while (node.nextSibling && node.nextSibling.nodeType === 3) {\n        node.nodeValue += node.nextSibling.nodeValue;\n        node.parentNode.removeChild(node.nextSibling);\n      }\n    } else {\n      this.normalizeTextNode(node.firstChild);\n    }\n    this.normalizeTextNode(node.nextSibling);\n  }\n\n  /**\n   * Callback when finished\n   * @callback Mark~commonDoneCallback\n   * @param {number} totalMatches - The number of marked elements\n   */\n  /**\n   * @typedef Mark~commonOptions\n   * @type {object.<string>}\n   * @property {string} [element=\"mark\"] - HTML element tag name\n   * @property {string} [className] - An optional class name\n   * @property {string[]} [exclude] - An array with exclusion selectors.\n   * Elements matching those selectors will be ignored\n   * @property {boolean} [iframes=false] - Whether to search inside iframes\n   * @property {Mark~commonDoneCallback} [done]\n   * @property {boolean} [debug=false] - Wheter to log messages\n   * @property {object} [log=window.console] - Where to log messages (only if\n   * debug is true)\n   */\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRegExpEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markRegExpNoMatchCallback\n   * @param {RegExp} regexp - The regular expression\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRegExpFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching string for the RegExp\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRegExpOptions\n   * @type {object.<string>}\n   * @property {Mark~markRegExpEachCallback} [each]\n   * @property {Mark~markRegExpNoMatchCallback} [noMatch]\n   * @property {Mark~markRegExpFilterCallback} [filter]\n   */\n  /**\n   * Marks a custom regular expression\n   * @param  {RegExp} regexp - The regular expression\n   * @param  {Mark~markRegExpOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRegExp(regexp, opt) {\n    this.opt = opt;\n    this.log(`Searching with expression \"${regexp}\"`);\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n    const eachCb = element => {\n      totalMatches++;\n      this.opt.each(element);\n    };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    this[fn](regexp, this.opt.ignoreGroups, (match, node) => {\n      return this.opt.filter(node, match, totalMatches);\n    }, eachCb, () => {\n      if (totalMatches === 0) {\n        this.opt.noMatch(regexp);\n      }\n      this.opt.done(totalMatches);\n    });\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markNoMatchCallback\n   * @param {RegExp} term - The search term that was not found\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching term\n   * @param {number} totalCounter - A counter indicating the number of all\n   * marks\n   * @param {number} termCounter - A counter indicating the number of marks\n   * for the specific match\n   */\n  /**\n   * @typedef Mark~markAccuracyObject\n   * @type {object.<string>}\n   * @property {string} value - A accuracy string value\n   * @property {string[]} limiters - A custom array of limiters. For example\n   * <code>[\"-\", \",\"]</code>\n   */\n  /**\n   * @typedef Mark~markAccuracySetting\n   * @type {string}\n   * @property {\"partially\"|\"complementary\"|\"exactly\"|Mark~markAccuracyObject}\n   * [accuracy=\"partially\"] - Either one of the following string values:\n   * <ul>\n   *   <li><i>partially</i>: When searching for \"lor\" only \"lor\" inside\n   *   \"lorem\" will be marked</li>\n   *   <li><i>complementary</i>: When searching for \"lor\" the whole word\n   *   \"lorem\" will be marked</li>\n   *   <li><i>exactly</i>: When searching for \"lor\" only those exact words\n   *   will be marked. In this example nothing inside \"lorem\". This value\n   *   is equivalent to the previous option <i>wordBoundary</i></li>\n   * </ul>\n   * Or an object containing two properties:\n   * <ul>\n   *   <li><i>value</i>: One of the above named string values</li>\n   *   <li><i>limiters</i>: A custom array of string limiters for accuracy\n   *   \"exactly\" or \"complementary\"</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markWildcardsSetting\n   * @type {string}\n   * @property {\"disabled\"|\"enabled\"|\"withSpaces\"}\n   * [wildcards=\"disabled\"] - Set to any of the following string values:\n   * <ul>\n   *   <li><i>disabled</i>: Disable wildcard usage</li>\n   *   <li><i>enabled</i>: When searching for \"lor?m\", the \"?\" will match zero\n   *   or one non-space character (e.g. \"lorm\", \"loram\", \"lor3m\", etc). When\n   *   searching for \"lor*m\", the \"*\" will match zero or more non-space\n   *   characters (e.g. \"lorm\", \"loram\", \"lor123m\", etc).</li>\n   *   <li><i>withSpaces</i>: When searching for \"lor?m\", the \"?\" will\n   *   match zero or one space or non-space character (e.g. \"lor m\", \"loram\",\n   *   etc). When searching for \"lor*m\", the \"*\" will match zero or more space\n   *   or non-space characters (e.g. \"lorm\", \"lore et dolor ipsum\", \"lor: m\",\n   *   etc).</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markIgnorePunctuationSetting\n   * @type {string[]}\n   * @property {string} The strings in this setting will contain punctuation\n   * marks that will be ignored:\n   * <ul>\n   *   <li>These punctuation marks can be between any characters, e.g. setting\n   *   this option to <code>[\"'\"]</code> would match \"Worlds\", \"World's\" and\n   *   \"Wo'rlds\"</li>\n   *   <li>One or more apostrophes between the letters would still produce a\n   *   match (e.g. \"W'o''r'l'd's\").</li>\n   *   <li>A typical setting for this option could be as follows:\n   *   <pre>ignorePunctuation: \":;.,-–—‒_(){}[]!'\\\"+=\".split(\"\"),</pre> This\n   *   setting includes common punctuation as well as a minus, en-dash,\n   *   em-dash and figure-dash\n   *   ({@link https://en.wikipedia.org/wiki/Dash#Figure_dash ref}), as well\n   *   as an underscore.</li>\n   * </ul>\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markOptions\n   * @type {object.<string>}\n   * @property {boolean} [separateWordSearch=true] - Whether to search for\n   * each word separated by a blank instead of the complete term\n   * @property {boolean} [diacritics=true] - If diacritic characters should be\n   * matched. ({@link https://en.wikipedia.org/wiki/Diacritic Diacritics})\n   * @property {object} [synonyms] - An object with synonyms. The key will be\n   * a synonym for the value and the value for the key\n   * @property {Mark~markAccuracySetting} [accuracy]\n   * @property {Mark~markWildcardsSetting} [wildcards]\n   * @property {boolean} [acrossElements=false] - Whether to find matches\n   * across HTML elements. By default, only matches within single HTML\n   * elements will be found\n   * @property {boolean} [ignoreJoiners=false] - Whether to ignore word\n   * joiners inside of key words. These include soft-hyphens, zero-width\n   * space, zero-width non-joiners and zero-width joiners.\n   * @property {Mark~markIgnorePunctuationSetting} [ignorePunctuation]\n   * @property {Mark~markEachCallback} [each]\n   * @property {Mark~markNoMatchCallback} [noMatch]\n   * @property {Mark~markFilterCallback} [filter]\n   */\n  /**\n   * Marks the specified search terms\n   * @param {string|string[]} [sv] - Search value, either a search string or\n   * an array containing multiple search strings\n   * @param  {Mark~markOptions} [opt] - Optional options object\n   * @access public\n   */\n  mark(sv, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n\n    const {\n        keywords: kwArr,\n        length: kwArrLen\n      } = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\n      sens = this.opt.caseSensitive ? '' : 'i',\n      handler = kw => { // async function calls as iframes are async too\n        let regex = new RegExp(this.createRegExp(kw), `gm${sens}`),\n          matches = 0;\n        this.log(`Searching with expression \"${regex}\"`);\n        this[fn](regex, 1, (term, node) => {\n          return this.opt.filter(node, kw, totalMatches, matches);\n        }, element => {\n          matches++;\n          totalMatches++;\n          this.opt.each(element);\n        }, () => {\n          if (matches === 0) {\n            this.opt.noMatch(kw);\n          }\n          if (kwArr[kwArrLen - 1] === kw) {\n            this.opt.done(totalMatches);\n          } else {\n            handler(kwArr[kwArr.indexOf(kw) + 1]);\n          }\n        });\n      };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    if (kwArrLen === 0) {\n      this.opt.done(totalMatches);\n    } else {\n      handler(kwArr[0]);\n    }\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRangesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {array} range - array of range start and end points\n   */\n  /**\n   * Callback if a processed range is invalid, out-of-bounds, overlaps another\n   * range, or only matches whitespace\n   * @callback Mark~markRangesNoMatchCallback\n   * @param {Mark~rangeObject} range - a range object\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRangesFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {array} range - array of range start and end points\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRangesOptions\n   * @type {object.<string>}\n   * @property {Mark~markRangesEachCallback} [each]\n   * @property {Mark~markRangesNoMatchCallback} [noMatch]\n   * @property {Mark~markRangesFilterCallback} [filter]\n   */\n  /**\n   * Marks an array of objects containing a start with an end or length of the\n   * string to mark\n   * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)\n   * array of objects\n   * @param  {Mark~markRangesOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRanges(rawRanges, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      ranges = this.checkRanges(rawRanges);\n    if (ranges && ranges.length) {\n      this.log(\n        'Starting to mark with the following ranges: ' +\n        JSON.stringify(ranges)\n      );\n      this.wrapRangeFromIndex(\n        ranges, (node, range, match, counter) => {\n          return this.opt.filter(node, range, match, counter);\n        }, (element, range) => {\n          totalMatches++;\n          this.opt.each(element, range);\n        }, () => {\n          this.opt.done(totalMatches);\n        }\n      );\n    } else {\n      this.opt.done(totalMatches);\n    }\n  }\n\n  /**\n   * Removes all marked elements inside the context with their HTML and\n   * normalizes the parent at the end\n   * @param  {Mark~commonOptions} [opt] - Optional options object\n   * @access public\n   */\n  unmark(opt) {\n    this.opt = opt;\n    let sel = this.opt.element ? this.opt.element : '*';\n    sel += '[data-markjs]';\n    if (this.opt.className) {\n      sel += `.${this.opt.className}`;\n    }\n    this.log(`Removal selector \"${sel}\"`);\n    this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, node => {\n      this.unwrapMatches(node);\n    }, node => {\n      const matchesSel = _domiterator__WEBPACK_IMPORTED_MODULE_0__.default.matches(node, sel),\n        matchesExclude = this.matchesExclude(node);\n      if (!matchesSel || matchesExclude) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, this.opt.done);\n  }\n}\n\n\n//# sourceURL=webpack://AccordionSearch/./node_modules/mark.js/src/lib/mark.js?");

/***/ }),

/***/ "./node_modules/mark.js/src/vanilla.js":
/*!*********************************************!*\
  !*** ./node_modules/mark.js/src/vanilla.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mark)\n/* harmony export */ });\n/* harmony import */ var _lib_mark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/mark */ \"./node_modules/mark.js/src/lib/mark.js\");\n\n\nfunction Mark(ctx) {\n  const instance = new _lib_mark__WEBPACK_IMPORTED_MODULE_0__.default(ctx);\n  this.mark = (sv, opt) => {\n    instance.mark(sv, opt);\n    return this;\n  };\n  this.markRegExp = (sv, opt) => {\n    instance.markRegExp(sv, opt);\n    return this;\n  };\n  this.markRanges = (sv, opt) => {\n    instance.markRanges(sv, opt);\n    return this;\n  };\n  this.unmark = (opt) => {\n    instance.unmark(opt);\n    return this;\n  };\n  return this;\n}\n\n//# sourceURL=webpack://AccordionSearch/./node_modules/mark.js/src/vanilla.js?");

/***/ }),

/***/ "./src/accordion-search.js":
/*!*********************************!*\
  !*** ./src/accordion-search.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AccordionSearch)\n/* harmony export */ });\n/* harmony import */ var mark_js_src_vanilla_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mark.js/src/vanilla.js */ \"./node_modules/mark.js/src/vanilla.js\");\n/* harmony import */ var _dom_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-animations */ \"./src/dom-animations.js\");\n\n\n\n\nclass AccordionSearch{\n\n    /**\n     * Init AccordionSearch\n     * @param {HTMLElement} ctx \n     * @param {Object} config \n     */\n    constructor( ctx, config = {} ){\n        this.ctx = ctx\n        this.config = { ...window.AccordionSearchConfig } \n        this.config = Object.assign( this.config, config )\n\n        // Save standards elements\n        this.elementSearchInput     = this.ctx.querySelector( '.as-search__input' )\n        this.elementSearchBtnSearch = this.ctx.querySelector( '.as-search__search_btn' )\n        this.elementSearchBtnClear  = this.ctx.querySelector( '.as-search__clear_btn' )\n        this.elementSearchResult    = this.ctx.querySelector( '.as-search-result' )\n        this.elementAccordions    = this.ctx.querySelectorAll( '.as-accordion' )\n\n        // Thx ====> https://markjs.io/\n        this.instanceMark = new mark_js_src_vanilla_js__WEBPACK_IMPORTED_MODULE_0__.default( this.config.searchOnlyTitle ? this.ctx.querySelectorAll( '.as-accordion .as-accordion__title' ) : this.elementAccordions )\n\n        this.itemsToShow = []\n\n        // Needed when feature \"loader\" activated\n        this.searchActivated = true\n\n        // Init Html & Event\n        this.initHtml()\n        this.initEvent()\n\n        // Feature \"queryUrl\"\n        if( this.config.queryUrl ){\n            const urlParams     = new URLSearchParams( window.location.search )\n            const paramValue    = urlParams.get( this.config.queryUrlName )\n\n            if( paramValue != null ){\n                this.elementSearchInput.value = paramValue\n                this.elementSearchInput.dispatchEvent( new KeyboardEvent( 'keyup' ) )\n\n                // Feature \"searchOnClick\"\n                if( this.config.searchOnClick ) this.elementSearchBtnSearch.click()\n            }\n\n        }\n\n        // Feature \"pagination\"\n        if( this.config.pagination ){\n            this.config.pagination = this.config.paginationLimit > 0\n            if( this.config.pagination ) this.pagination()\n        }\n\n    }\n\n    initHtml(){\n        // Close All & add icon in accordion title\n        for (const elementAccordion of this.elementAccordions) {\n            elementAccordion.querySelector( '.as-accordion__content' ).classList.add( 'as-d-none' )\n            elementAccordion.querySelector( '.as-accordion__title' ).innerHTML = `<span class=\"as-accordion__title-icon\">${ this.config.iconOpen }</span>` + elementAccordion.querySelector( '.as-accordion__title' ).innerHTML\n        }\n\n        // Init standards icons elements\n        this.elementSearchBtnSearch.innerHTML   = this.config.iconSearch\n        this.elementSearchBtnClear.innerHTML    = this.config.iconClear\n\n        // Init standards class elements\n        this.elementSearchResult.classList.add( 'as-d-none' )\n        this.elementSearchBtnSearch.classList.add( 'as-d-none' )\n        this.elementSearchBtnClear.classList.add( 'as-d-none' )\n\n        // Feature \"searchOnClick\"\n        if( this.config.searchOnClick ) this.elementSearchBtnSearch.classList.add( 'as-cursor-pointer' )\n\n        // Feature \"suggestionBox\"\n        if( this.config.suggestionBox && Array.isArray( this.config.suggestionBoxKeywords ) && this.config.suggestionBoxKeywords.length > 0 ){\n            \n            // Create container global\n            let divSuggestionBox = document.createElement( 'div' )\n            divSuggestionBox.classList.add( 'as-search-suggestion-box' )\n            \n            // Create title\n            let titleSuggestionBox = document.createElement( 'p' )\n            titleSuggestionBox.classList.add( 'as-search-suggestion-box__title' )\n            titleSuggestionBox.innerHTML = this.config.suggestionBoxTitle\n            divSuggestionBox.appendChild( titleSuggestionBox )\n\n            // Create container items suggestions\n            let itemsSuggestionBox = document.createElement( 'div' )\n            itemsSuggestionBox.classList.add( 'as-search-suggestion-box__items' )\n            \n            // Create all keyword\n            for (const keyword of this.config.suggestionBoxKeywords) {\n                if( keyword.length <= 2 ) continue;\n                let item = document.createElement( 'p' )\n                item.innerText = keyword\n                item.addEventListener( 'click', (e) => this.onSuggestion( e.currentTarget ) )\n                itemsSuggestionBox.appendChild( item )\n            }\n\n            divSuggestionBox.appendChild( itemsSuggestionBox )\n\n            // add to html\n            this.ctx.querySelector( '.as-search_container' ).after( divSuggestionBox )\n        }\n\n        // Feature \"btnOpenCloseAll\"\n        if( this.config.btnOpenCloseAll ){\n\n            // Create container global\n            let divBtns = document.createElement( 'div' )\n            divBtns.classList.add( 'as-accordion-btn-all' )\n\n            // Create button open\n            let smallBtnOpen = document.createElement( 'small' )\n            smallBtnOpen.classList.add( 'as-accordion-btn-all__open' )\n            smallBtnOpen.innerHTML = this.config.iconOpenAll\n            divBtns.appendChild( smallBtnOpen )\n\n            // Create button close\n            let smallBtnClose = document.createElement( 'small' )\n            smallBtnClose.classList.add( 'as-accordion-btn-all__close' )\n            smallBtnClose.innerHTML = this.config.iconCloseAll\n            divBtns.appendChild( smallBtnClose )\n\n            // add to html\n            this.elementSearchResult.after( divBtns )\n        }\n\n        // Feature \"itemsOpened\"\n        if( this.config.itemsOpened != 0 ){\n\n            // If array - Open only the indexes entered\n            if( Array.isArray( this.config.itemsOpened) ){\n                for (let index = 0; index < this.config.itemsOpened.length; index++) {\n                    if( this.elementAccordions[ this.config.itemsOpened[ index ] ] != undefined ){\n                        this.openAccordion( this.elementAccordions[ this.config.itemsOpened[ index ] ] )\n                    }\n                }\n            // If number - Open n elements\n            }else if( Number.isInteger( this.config.itemsOpened ) && this.config.itemsOpened < this.elementAccordions.length ){\n                for (let index = 0; index < this.config.itemsOpened; index++) {\n                    if( this.elementAccordions[ index ] != undefined ){\n                        this.openAccordion( this.elementAccordions[ index ] )\n                    }\n                }\n            // If \"all\" - Open all\n            }else if( this.config.itemsOpened == \"all\" ){\n                this.onAll()\n            }\n        }\n\n    }\n\n    /**\n     * Init all events\n     */\n    initEvent(){\n        let accordionTitles = this.ctx.querySelectorAll( '.as-accordion__title' )\n\n        // Title bar accordion - Click\n        for (const accordionTitle of accordionTitles) {\n            accordionTitle.addEventListener( 'click', (e) => {\n                e.preventDefault()\n                const accordion = e.currentTarget.parentElement\n                if( accordion.querySelector( '.as-accordion__content' ).classList.contains( 'as-d-none' ) ) {\n                    this.openAccordion( accordion )\n                }else{\n                    this.closeAccordion( accordion )\n                }\n            } )\n        }\n\n        // Input search - Keyup\n        this.elementSearchInput.addEventListener( 'keyup', (e) => {\n            if( ! this.searchActivated ) return false\n\n            if( e.target.value.length <= 2 ) {\n                this.reset() \n            }else{\n                this.elementSearchBtnSearch.classList.remove( 'as-d-none' )\n                this.elementSearchBtnClear.classList.remove( 'as-d-none' )\n\n                // Feature \"searchOnClick\"\n                if( ! this.config.searchOnClick ) this.search()\n            }\n        } )\n\n        // Feature \"searchOnClick\"\n        if( this.config.searchOnClick ){\n            this.elementSearchBtnSearch.addEventListener( 'click', (e) => {\n                this.search()\n            } )\n        }\n\n        // Clear button\n        this.elementSearchBtnClear.addEventListener( 'click', (e) => {\n            if( ! this.searchActivated ) return false\n            this.elementSearchInput.value = \"\"\n            this.reset()\n        } )\n\n        // Feature \"btnOpenCloseAll\"\n        if( this.config.btnOpenCloseAll ){\n            this.ctx.querySelector( '.as-accordion-btn-all__open' ).addEventListener( 'click', (e) => this.onAll( ) )\n            this.ctx.querySelector( '.as-accordion-btn-all__close' ).addEventListener( 'click', (e) => this.onAll( false ) )\n        }\n\n    }\n\n    /**\n     *\n     * @param {HTMLElement} accordion \n     */\n    openAccordion( accordion ){\n        _dom_animations__WEBPACK_IMPORTED_MODULE_1__.DOMAnimations.slideDown( accordion.querySelector( '.as-accordion__content' ) )\n        accordion.querySelector( '.as-accordion__title-icon' ).innerHTML = this.config.iconClose\n    }\n\n    /**\n     * \n     * @param {HTMLElement} accordion \n     */\n    closeAccordion( accordion ){\n        _dom_animations__WEBPACK_IMPORTED_MODULE_1__.DOMAnimations.slideUp( accordion.querySelector( '.as-accordion__content' ) )\n        accordion.querySelector( '.as-accordion__title-icon' ).innerHTML = this.config.iconOpen\n    }\n\n    /**\n     * Find the match in the titles (and contents)\n     * @param {HTMLElement[]} elements \n     */\n    search( ){\n\n        if( ! this.searchActivated ) return false\n\n        // Feature \"loader\"\n        if( this.config.loader ) this.loader( true )\n\n        this.itemsToShow = []\n\n        // Reset marks\n        this.instanceMark.unmark() \n\n        // Create marks\n        this.instanceMark.mark( this.elementSearchInput.value, {\n            separateWordSearch: false,\n            caseSensitive: this.config.caseSensitive,\n            \"each\": ( node ) => this.addItemToShow( node ),\n            \"done\": ( counter ) => this.result( counter )\n        } )\n    }\n\n    /**\n     * Reset all & close all \n     */\n    reset(){\n        // Feature \"loader\"\n        if( this.config.loader ) this.loader( true )\n\n        this.elementSearchBtnSearch.classList.add( 'as-d-none' )\n        this.elementSearchBtnClear.classList.add( 'as-d-none' )\n        this.elementSearchResult.classList.add( 'as-d-none' )\n\n        // Remove marks\n        this.instanceMark.unmark()\n\n        for ( const accordion of this.elementAccordions ) {\n            accordion.classList.remove('as-d-none')\n            // Close accordion\n            if( ! accordion.querySelector( '.as-accordion__content' ).classList.contains( 'as-d-none' ) ) this.closeAccordion(accordion)\n            \n            // Remove hide from feature \"pagination\"\n            if( accordion.classList.contains( 'as-accordion-pagination-hide' ) ) accordion.classList.remove( 'as-accordion-pagination-hide' )\n        }\n\n        // Feature \"btnOpenCloseAll\"\n        if( this.config.btnOpenCloseAll ) this.ctx.querySelector( '.as-accordion-btn-all' ).classList.remove( 'as-d-none' )\n\n        // Feature \"pagination\"\n        if( this.config.pagination ) this.pagination()\n\n        // Feature \"loader\"\n        if( this.config.loader ) this.loader( false )\n    }\n\n    /**\n     * Marks - Event \"done\" - When all marks are applied\n     * @param {Number} nbResults \n     */\n    result( nbResults ){\n        const resultString = nbResults == 0 ? this.config.msgNoResult : ( nbResults == 1 ? this.config.msgItemFound : this.config.msgItemsFound )\n        this.elementSearchResult.innerHTML = nbResults + ' ' + resultString;\n        this.elementSearchResult.classList.remove( 'as-d-none' )\n\n        // Saves accordions with marks and hide others\n        for ( const accordion of this.elementAccordions ) {\n            if( !this.itemsToShow.includes( accordion ) ){\n                accordion.classList.add( 'as-d-none' )\n            }else{\n                accordion.classList.remove( 'as-d-none' )\n            }\n            if( accordion.classList.contains( 'as-accordion-pagination-hide' ) ){\n                accordion.classList.remove( 'as-accordion-pagination-hide' )\n            }\n        }\n\n        // Open accordions with marks\n        for (const itemToShow of this.itemsToShow) {\n            this.openAccordion( itemToShow )\n        }\n\n        // Feature \"btnOpenCloseAll\"\n        if( this.config.btnOpenCloseAll ){\n            if( nbResults == 0 ){\n                this.ctx.querySelector( '.as-accordion-btn-all' ).classList.add( 'as-d-none' )\n            }else{\n                this.ctx.querySelector( '.as-accordion-btn-all' ).classList.remove( 'as-d-none' )\n            }\n        }\n\n        // Feature \"pagination\"\n        if( this.config.pagination ) this.pagination()\n\n        // Feature \"loader\"\n        if( this.config.loader ) this.loader( false )\n    }\n\n    /**\n     * Marks - Event \"each\" - Save the accordion with marked\n     * @param {HTMLElement} node \n     */\n    addItemToShow( node ){\n        const accordionParent = node.closest( '.as-accordion' )\n        if( ! this.itemsToShow.includes( accordionParent ) ) this.itemsToShow.push( accordionParent )\n    }\n\n    /**\n     * Apply on all accordions (open/close)\n     * @param {Boolean} open \n     */\n    onAll( open = true ){\n        for ( const accordion of this.elementAccordions ) {\n            const currentIsHidden = accordion.querySelector( '.as-accordion__content' ).classList.contains( 'as-d-none' )\n            if( open && currentIsHidden ){\n                this.openAccordion( accordion )\n            }else if( ! open && ! currentIsHidden ){\n                this.closeAccordion( accordion )\n            }\n        }\n    }\n\n    /**\n     * Event Click - When click on keyword suggestion\n     * @param {HTMLElement} item \n     */\n    onSuggestion( item ){\n        if( ! this.searchActivated ) return false\n        this.elementSearchInput.value = item.textContent\n        this.elementSearchInput.dispatchEvent( new KeyboardEvent( 'keyup' ) )\n\n        // Feature \"searchOnClick\" - Trigger click\n        if( this.config.searchOnClick ) this.elementSearchBtnSearch.click()\n    }\n\n    /**\n     * To manage pagination\n     * @param {Number} currentPaginationItem \n     */\n    pagination( currentPaginationItem = 0 ){\n        let divPagination = this.ctx.querySelector( '.as-accordion-pagination' )\n\n        // Create pagination if not exist\n        if( divPagination == null ){\n            divPagination = document.createElement( 'div' )\n            divPagination.classList.add( 'as-accordion-pagination' )\n        }else{\n            // Remove all items in pagination\n            divPagination.querySelectorAll('*').forEach(n => n.remove())\n        }\n\n        const nbItems = Math.ceil( this.ctx.querySelectorAll( '.as-accordion:not(.as-d-none)' ).length / this.config.paginationLimit )\n\n        let currentPaginationItemElement\n\n        // Create all items for pagination\n        for ( const index = 0; index < nbItems; index++ ) {\n            let item = document.createElement( 'p' )\n            item.innerText = index + 1\n            if( currentPaginationItem == index ){\n                currentPaginationItemElement = item\n                item.classList.add( 'as-accordion-pagination__active' )\n            }else{\n                item.classList.remove( 'as-accordion-pagination__active' )\n            }\n            item.addEventListener( 'click', (e) => this.pagination( index ) )\n            divPagination.appendChild( item )\n        }\n\n        this.ctx.appendChild( divPagination )\n\n        this.onPagination( currentPaginationItemElement )\n    }\n\n    /**\n     * Shows the correct accordions \n     * @param {HTMLElement} item \n     */\n    onPagination( item ){\n\n        const items = Array.prototype.slice.call( this.ctx.querySelectorAll( '.as-accordion-pagination > *' ) )\n\n        const itemPosition = items.indexOf( item )\n\n        const startPositionSlice = itemPosition * this.config.paginationLimit\n\n        const currentAccordionsVisible = Array.prototype.slice.call( this.ctx.querySelectorAll( '.as-accordion:not(.as-d-none)' ) )\n\n        for (const accordion of currentAccordionsVisible) {\n            accordion.classList.add( 'as-accordion-pagination-hide' )\n        }\n\n        const newAccordionsVisible = currentAccordionsVisible.slice( startPositionSlice, startPositionSlice + this.config.paginationLimit )\n\n        for (const accordion of newAccordionsVisible) {\n            accordion.classList.remove( 'as-accordion-pagination-hide' )\n        }\n    }\n\n    /**\n     * Add loader and block search & reset\n     * @param {Boolean} add \n     */\n    loader( add = true ){\n\n        this.searchActivated = !add\n\n        this.elementSearchBtnSearch.classList.toggle( 'as-cursor-not-allowed' )\n        this.elementSearchBtnClear.classList.toggle( 'as-cursor-not-allowed' )\n        this.elementSearchInput.classList.toggle( 'as-cursor-not-allowed' )\n        if( this.config.suggestionBox ){\n            for (const item of this.ctx.querySelectorAll( '.as-search-suggestion-box__items > *' )) {\n                item.classList.toggle( 'as-cursor-not-allowed' )\n            }\n        }\n        \n        this.elementSearchInput.readOnly = add\n\n        const iconToAdd = add ? this.config.iconLoader : this.config.iconSearch\n        this.elementSearchBtnSearch.innerHTML = iconToAdd\n    }\n\n}\n\n\n//# sourceURL=webpack://AccordionSearch/./src/accordion-search.js?");

/***/ }),

/***/ "./src/dom-animations.js":
/*!*******************************!*\
  !*** ./src/dom-animations.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOMAnimations\": () => (/* binding */ DOMAnimations)\n/* harmony export */ });\nclass DOMAnimations{\n    static slideUp( element, duration = 500 ){\n        element.style.height = element.offsetHeight + 'px'\n        element.offsetHeight  // redraw\n        element.style.overflow = 'hidden'\n        element.style.height = 0\n        element.style.paddingTop = 0\n        element.style.paddingBottom = 0\n        element.style.marginTop = 0\n        element.style.marginBottom = 0\n        element.style.transitionProperty = 'height, margin, padding'\n        element.style.transitionDuration = duration + 'ms'\n\n        setTimeout(() => {\n            element.classList.add( 'as-d-none' )\n            element.style.removeProperty('height')\n            element.style.removeProperty('padding-top')\n            element.style.removeProperty('padding-bottom')\n            element.style.removeProperty('margin-top')\n            element.style.removeProperty('margin-bottom')\n            element.style.removeProperty('overflow')\n            element.style.removeProperty('transition-duration')\n            element.style.removeProperty('transition-property')\n        }, duration);\n\n    }\n\n    static slideDown( element, duration = 500 ){\n        element.classList.remove( 'as-d-none' )\n        element.style.overflow = 'hidden'\n        element.style.paddingTop = 0\n        element.style.paddingBottom = 0\n        element.style.marginTop = 0\n        element.style.marginBottom = 0\n        let height = element.offsetHeight\n        element.style.height = 0\n        element.offsetHeight // redraw\n        element.style.transitionProperty = 'height, margin, padding'\n        element.style.transitionDuration = duration + 'ms'\n        element.style.height = height + 'px'\n        element.style.removeProperty('padding-top')\n        element.style.removeProperty('padding-bottom')\n        element.style.removeProperty('margin-top')\n        element.style.removeProperty('margin-bottom')\n\n        setTimeout(() => {\n            element.style.removeProperty('height')\n            element.style.removeProperty('overflow')\n            element.style.removeProperty('transition-duration')\n            element.style.removeProperty('transition-property')\n        }, duration);\n\n    }\n}\n\n//# sourceURL=webpack://AccordionSearch/./src/dom-animations.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const AccordionSearch = __webpack_require__(/*! ./accordion-search */ \"./src/accordion-search.js\").default\n\nwindow.AccordionsSearchs = []\nwindow.AccordionSearchConfig = {\n    searchOnlyTitle: false, // Allow search only accordion title.\n    searchOnClick: false, // Allow search only on click icon search in input\n    caseSensitive: false,\n    itemsOpened: 0, // Int = number element to opened, [0,4,10] = position of elements to opened, \"all\" = all elements opened\n    suggestionBox: false, // display a suggestion box.\n    suggestionBoxTitle: 'Popular Searches:', // Title of suggestions box.\n    suggestionBoxKeywords: [], // Items of suggestions box, ex [ 'text1', 'text2' ], item.length > 2.\n    btnOpenCloseAll: false, //Display button open/close all.\n    pagination: false, // pagination status\n    paginationLimit: 2, // item per page\n    loader: false, // Add loader on search\n    queryUrl: false,\n    queryUrlName: 'asQuery',\n    msgItemFound: 'Item Found !',\n    msgItemsFound: 'Items Found !',\n    msgNoResult: 'Nothing Found !',\n    iconSearch: '<i class=\"fas fa-search\"></i>',\n    iconClear: '<i class=\"fas fa-times\"></i>',\n    iconLoader: '<i class=\"fas fa-spinner fa-spin\"></i>',\n    iconOpen: '<i class=\"fas fa-plus\"></i>',\n    iconClose: '<i class=\"fas fa-minus\"></i>',\n    iconOpenAll: '<i class=\"fas fa-plus\"></i>',\n    iconCloseAll: '<i class=\"fas fa-minus\"></i>',\n} \n\nmodule.exports = AccordionSearch\n\n//# sourceURL=webpack://AccordionSearch/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	AccordionSearch = __webpack_exports__;
/******/ 	
/******/ })()
;